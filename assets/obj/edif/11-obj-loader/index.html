<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"
    ></script>
    <script type="module">
      import * as THREE from "https://unpkg.com/three/build/three.module.js";
      import Stats from "https://unpkg.com/three/examples/jsm/libs/stats.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js";
      import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.117.1/examples/jsm/loaders/OBJLoader.js";

      ("use strict");

      let renderer, scene, camera, orbitControls, model, stats, gui, rin;

      function init(event) {
        // RENDERER ENGINE
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
        renderer.setClearColor(new THREE.Color(0, 0, 0));
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // SCENE
        scene = new THREE.Scene();

        // MODELS
        const axes = new Axes();
        const floor = new Floor();
        const car = new SportsCar();

        // SCENE GRAPH
        scene.add(axes);
        scene.add(floor);

        // CAMERA (PERSPECTIVE)
        const fov = 60; // Field ov view
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.01;
        const far = 10000.0;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(1, 1, 3);
        // CAMERA CONTROLS
        orbitControls = new OrbitControls(camera, renderer.domElement);
        //orbitControls.target = model.position;
        orbitControls.update();

        // SETUP STATS
        stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom);

        // GUI
        gui = new dat.GUI();
        // SCENE-MENU
        const guiSceneMenu = gui.addFolder("Scene Menu");
        guiSceneMenu
          .add(floor, "visible")
          .setValue(floor.visible)
          .name("Floor")
          .listen()
          .onChange(function (value) {
            floor.setVisible(value);
          });
        guiSceneMenu
          .add(axes, "visible")
          .setValue(axes.visible)
          .name("World Axes")
          .listen()
          .onChange(function (value) {
            axes.setVisible(value);
          });
        guiSceneMenu.open();

        // DRAW SCENE IN A RENDER LOOP (ANIMATION)
        renderLoop();
      }

      function renderLoop() {
        stats.begin();
        renderer.render(scene, camera); // DRAW THE SCENE GRAPH
        updateScene();
        stats.end();
        requestAnimationFrame(renderLoop);
      }

      function updateScene() {
        if (model && model.rotate) {
          model.rotation.y = model.rotation.y + 0.01;
        }
      }

      // EVENT LISTENERS & HANDLERS
      document.addEventListener("DOMContentLoaded", init);

      window.addEventListener(
        "resize",
        () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        },
        false
      );

      class Axes extends THREE.AxesHelper {
        constructor(size = 10, visible = true) {
          super(size);
          this.size = size;
          this.visible = visible;
        }
        setVisible(value) {
          this.visible = value;
        }
      }

      class Floor extends THREE.Group {
        constructor(size = 100) {
          super();
          this.size = size;
          const geometry = new THREE.PlaneGeometry(size, size);
          const material = new THREE.MeshBasicMaterial({ color: 0x808080 });
          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.rotation.x = -Math.PI / 2;
          this.gridHelper = new THREE.GridHelper(
            size,
            size / 4,
            0xff0000,
            0x000000
          );
          // CHILDREN
          this.add(this.mesh);
          this.add(this.gridHelper);
        }
        setVisible(value = true) {
          this.visible = value;
        }
        setWireframe(value = true) {
          this.material.wireframe = value;
        }
        setColor(color) {
          this.mesh.material.color.setHex(color);
        }
      }

      class Cube extends THREE.Group {
        constructor(size = 1, color = 0xff0000, colorWire = 0xffffff) {
          super();
          this.size = size;
          this.color = color;
          this.colorWire = colorWire;
          this.rotate = false;
          const geometry = new THREE.BoxGeometry(size, size);
          const material = new THREE.MeshBasicMaterial({ color });
          const materialWire = new THREE.MeshBasicMaterial({
            wireframe: true,
            color: colorWire,
          });
          this.mesh = new THREE.Mesh(geometry, material);
          this.wire = new THREE.Mesh(geometry, materialWire);
          // CHILDREN
          this.add(this.mesh);
          this.add(this.wire);
        }
        setVisible(value = true) {
          this.visible = value;
        }
        setWireframe(value = true) {
          this.mesh.material.wireframe = value;
        }
        setColor(color) {
          this.color = color;
          this.mesh.material.color.setHex(color);
        }
        setWireColor(color) {
          this.wireColor = color;
          this.wire.material.color.setHex(color);
        }
        setOnFloor() {
          this.mesh.geometry.computeBoundingBox();
          const bBox = this.mesh.geometry.boundingBox;
          this.position.y = -bBox.min.y;
        }
      }

      class SportsCar extends THREE.Group {
        constructor(objFileName = "./assets/obj/SUV.obj") {
          super();
          this.color = 0xcc0000;
          this.wireColor = 0xffffff;
          this.doubleSide = false;
          this.rotate = false;
          this.objFileName = objFileName;
          this.loadOBJModel(objFileName);
        }
        loadOBJModel(objFileName) {
          // instantiate a loader
          const loader = new OBJLoader();
          // load a resource
          model = this;
          loader.load(
            objFileName,
            // called when resource is loaded
            function (object) {
              // SOLID
              object.traverse(function (child) {
                if (child.isMesh) {
                  child.material = new THREE.MeshBasicMaterial({
                    color: model.color,
                  });
                }
              });
              model.solid = object;
              // WIRE
              model.wire = object.clone();
              model.wire.traverse(function (child) {
                if (child.isMesh) {
                  child.material = new THREE.MeshBasicMaterial({
                    wireframe: true,
                    color: model.wireColor,
                  });
                }
              });
              // CHILDREN
              model.add(model.solid);
              model.add(model.wire);
              scene.add(model);
              model.setOnFloor();

              // MODEL-MENU
              const guiModelMenu = gui.addFolder("Model Menu");
              // GUI-Model
              guiModelMenu
                .add(model, "visible")
                .setValue(model.visible)
                .name("Visible")
                .listen()
                .onChange(function (value) {});
              guiModelMenu
                .add(model.solid, "visible")
                .setValue(model.solid.visible)
                .name("Wireframe")
                .listen()
                .onChange(function (value) {});
              guiModelMenu
                .add(model, "doubleSide")
                .setValue(model.doubleSide)
                .name("Double Side")
                .listen()
                .onChange(function (value) {
                  model.setDoubleSide(value);
                });
              guiModelMenu
                .addColor(model, "color")
                .name("Color")
                .setValue(model.color)
                .listen()
                .onChange(function (value) {
                  model.setColor(value);
                });
              guiModelMenu
                .addColor(model, "wireColor")
                .name("Wire Color")
                .setValue(model.wireColor)
                .listen()
                .onChange(function (value) {
                  model.setWireColor(value);
                });
              guiModelMenu
                .add(model, "rotate")
                .setValue(model.rotate)
                .name("Rotate")
                .listen()
                .onChange(function (value) {});
            },
            // called when loading is in progresses
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
            },
            // called when loading has errors
            function (error) {
              console.log("An error happened" + error);
            }
          );
        }
        setColor(hexColor) {
          this.color = hexColor;
          this.solid.traverse(function (child) {
            if (child.isMesh) {
              child.material.color.setHex(hexColor);
            }
          });
        }
        setWireColor(hexColor) {
          this.wireColor = hexColor;
          this.wire.traverse(function (child) {
            if (child.isMesh) {
              child.material.color.setHex(hexColor);
            }
          });
        }
        setDoubleSide(value) {
          this.doubleSide = value;
          this.solid.traverse(function (child) {
            if (child.isMesh) {
              if (value) {
                child.material.side = THREE.DoubleSide;
              } else {
                child.material.side = THREE.FrontSide;
              }
            }
          });
        }
        setOnFloor() {
          const bBox = new THREE.Box3();
          bBox.setFromObject(this.solid);
          this.position.y = -bBox.min.y;
        }
      }
    </script>
  </body>
</html>
